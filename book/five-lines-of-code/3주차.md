# 3주차 (5장)

## 5장) 유사한 코드 융합하기

### 1) 유사한 클래스 통합하기

클래스를 통합하는 것은 분수를 더하는 알고리즘과 유사합니다.

분수를 더하는 첫 번째 단계는 분모를 동일하게 만드는 것이고 클래스를 결합하는 첫 번째 단계는 **상수 메서드를 제외한 클래스의 모든 것을 동일하게 만드는 것**입니다. 분수를 더하는 두 번째 단계는 실제 더하기입니다. 클래스의 경우에는 **실제로 합치는 것**입니다.

**5.1.1 리팩터링 패턴: 유사 클래스 통합**

일련의 상수 메서드를 공통으로 가진 두 개 이상의 클래스에서 이 일련의 상수 메서드가 클래스에 따라 다른 값을 반환할 때 이 리팩터링 패턴을 사용할 수 있습니다.

여기서 일련의 상수 메서드 집합을 **기준(basis)**라고 합니다. 일련의 상수 메서드가 두 개일 때 두 개의 접점을 가진 기준이라고 합니다.

### 2) 복잡한 조건 통합하기

**5.3.1 조건을 위한 산술 규칙 사용**

`|| (및 |)` 은 +(더하기)처럼 동작하고, `&& (및 &)` 은 x(곱하기)처럼 동작합니다.

함수의 느낄 수 있는 스멜에서 ‘명령’은 부작용이 있는 모든 것을 의미하고 ‘질의’는 순수한 것을 의미합니다. 이 스멜을 따르는 쉬운 방법은 `void` 메서드에서만 부수적인 동작을 허용하는 것입니다.

### 4) 클래스 간의 코드 통합

**5.4.2 리팩터링 패턴: 전략 패턴의 도입**

다른 클래스를 인스턴스화해서 변형(variance)을 도입하는 개념을 **전략 패턴**이라고 합니다. 전략이 필드를 가지고 있는 경우 이를 **상태 패턴**(state pattern)이라고 합니다.

이러한 전략 패턴은 두 가지 상황에서 도입할 수 있습니다.

1. 코드에 변형을 도입하고 싶어서 리팩터링을 수행하는 경우
2. 떨어지는 성질을 코드화했던 상황에서 바로 변형의 추가가 필요하다고 예상하지 않았을 경우 (클래스 간의 동작을 통합하려는 경우)

**5.4.3 규칙: 구현제가 하나뿐인 인터페이스를 만들지 말 것**

하나의 구현 클래스만 존재하는데 해당 파일을 지원하는 인터페이스를 따로 파일로 분리할 경우 두 배의 파일을 만들게 되는 것입니다. 이는 상당한 오버헤드를 초대합니다.

아무런 구현체가 없는 인터페이스를 갖는 것이 합리적인 경우가 있는데 가장 일반적으로 비교자(comparator)와 같은 항목에 대해 익명 클래스를 사용하거나 익명의 내부 클래스를 통해 더 엄격한 캡슐화를 수행하려는 경우 유용합니다.

> **“추상화는 인지된 복잡성의 감소를 위해 실제의 복잡성의 증가를 허용하는 것이다.”**  
> 존 카맥
